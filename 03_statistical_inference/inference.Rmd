---
title: "Inference"
author: "Raúl López Domínguez"
date: "`r Sys.Date()`"
output: html_notebook
---

Statistical inference is the part of statistics that helps distinguish patterns arising from signal from those arising from chance. Statistical inference is a broad topic and here we go over the very basics using polls as a motivating example. To describe the concepts, we complement the mathematical formulas with Monte Carlo simulations and R code.

# Sampling Model Parameters and Estimates

We want to predict the proportion of the blue beads in the urn, the parameter p. The proportion of red beads in the urn is 1-p and the spread is 2p-1.

In a sampling model, the collection of elements in the urn is called the population. The proportion of blue beads in the population p is called parameter. The number of draws is the sample. The task of statistical inference is to estimate an unknown population parameter using observed data from a sample.

## Sample Average

Conducting an opinion poll is being modeled as taking a random sample from an urn. We are proposing the use of the proportion of blue beads in our sample as an estimate of the parameter p. We start by defining the random variable X as X = 1 if we pick a blue bead and X = 0 if it is red. When we sample N beads, the average of the draws (X1, X2, Xn) is equivalent to the proportion of blue beads in our sample. We use the symbol ^X to represent this average. We can calculate X^ as a sum of draw divided by N.

```{r}
set.seed(123)
N <- 25
draw_res <- sample(c(0,1), N, replace = T)
sum_draw_res <- sum(draw_res)
X_avg <- sum_draw_res / N
X_avg
```

We know that the average of the 0s and 1s in the urn must be p, the proportion of blue beads. Here we encounter an important difference with what we did in the Probability chapter: we don’t know what is in the urn. We know there are blue and red beads, but we don’t know how many of each. This is what we want to find out: we are trying to estimate p.

## Parameters

Just like we use variables to define unknowns in systems of equations, in statistical inference we define parameters to define unknown parts of our models. In the urn model which we are using to mimic an opinion poll, we do not know the proportion of blue beads in the urn. We define the parameters p to represent this quantity. p is the average of the urn because if we take the average of the 1s (blue) and 0s (red), we get the proportion of blue beads. Since our main goal is figuring out what is p, we are going to estimate this parameter.

## Properties of the estimates. EXpected value and standard error

To understand how good our estimate is, we will describe the statistical properties of the random variable defined above: the sample proportion ^X. Remember that ^X is the sum of independent draws so the rules we covered in the probability chapter apply.

As E[X] = N\*p; the expected value of the avg ^X is N\*p/N; so E[^X] = p

As SE[E] = sqrt(N\*SD; so SE[^X] = sqrt(p*(1-p)/N)

This result reveals the power of polls. The expected value of the sample proportion ^X is the parameter of interest p and we can make the standard error as small as we want by increasing N. The law of large numbers tells us that with a large enough poll, our estimate converges to p.

If we take a large enough poll to make our standard error about 1%, we will be quite certain about who will win. But how large does the poll have to be for the standard error to be this small?

One problem is that we do not know p, so we can’t compute the standard error. However, for illustrative purposes, let’s assume that p=0.51 and make a plot of the standard error versus the sample size N:

```{r}
library(ggplot2)

p <- 0.51
Ns <- seq(10,10000, 10)
se_values <- sapply(Ns, function(N){
  sqrt(p*(1-p)/N)
})

se_df <- data.frame(se = se_values, N = Ns)

ggplot(se_df, aes(x = N, y = se))+
  geom_line()
```

From the plot we see that we would need a poll of over 10,000 people to get the standard error that low. We rarely see polls of this size due in part to costs. From the Real Clear Politics table, we learn that the sample sizes in opinion polls range from 500-3,500 people. For a sample size of 1,000 and p=0.51, the standard error is:

```{r}
sqrt(p*(1-p))/sqrt(1000)
```

or 1.5 percentage points. So even with large polls, for close elections, ^X can lead us astray if we don’t realize it is a random variable

# Exercises

1) Suppose you poll a population in which a proportion p of voters are Democrats and p-1 are Republicans. Your sample size is N = 25. Consider the random variable S, which is the total number of Democrats in your sample. What is the expected value of this random variable S?

E[S] = Np

2) What is the standard error of S?

SE[S] = sqrt(Np(1-p))

3) Consider the random variable S/N, which is equivalent to the sample average that we have been denoting as ^X. The variable N represents the sample size and p is the proportion of Democrats in the population. What is the expected value of?

E[^X] = p

4) What is the standard error of the sample average, ^X?

SE[^X] = sqrt(p(1-p)/N)

5) Write a line of code that calculates the standard error se of a sample average when you poll 25 people in the population. Generate a sequence of 100 proportions of Democrats p that vary from 0 (no Democrats) to 1 (all Democrats). Plot se versus p for the 100 different proportions.

```{r}
# `N` represents the number of people polled
N <- 25

# Create a variable `p` that contains 100 proportions ranging from 0 to 1 using the `seq` function
p <- seq(0,1, length = 100)

# Create a variable `se` that contains the standard error of each sample average
se <- sqrt(p * (1 - p)/N)

# Plot `p` on the x-axis and `se` on the y-axis
plot(p,se)
```

6) Using the same code as in the previous exercise, create a for-loop that generates three plots of p versus se when the sample sizes equal N = 25, N = 100, and N = 1000.

```{r}
# The vector `p` contains 100 proportions of Democrats ranging from 0 to 1 using the `seq` function
p <- seq(0, 1, length = 100)

# The vector `sample_sizes` contains the three sample sizes
sample_sizes <- c(25, 100, 1000)

# Write a for-loop that calculates the standard error `se` for every value of `p` for each of the three samples sizes `N` in the vector `sample_sizes`. Plot the three graphs, using the `ylim` argument to standardize the y-axis across all three plots.
for(N in sample_sizes){
  se <- sqrt(p*(1-p)/N)
  plot(p, se, ylim = c(0,0.5/sqrt(25)))
}
```

7) Our estimate for the difference in proportions of Democrats and Republicans is d = ^X - (1 - ^X). Which derivation correctly uses the rules we learned about sums of random variables and scaled random variables to derive the expected value of?.

E[^X - (1 - ^X)] = E[2^X -1] = 2E[^X] - 1 = 2p -1 = p - (1 - p)

8) Which derivation correctly uses the rules we learned about sums of random variables and scaled random variables to derive the standard error of d?

SE[^X - (1 - ^X)] = SE[2^X -1] = 2SE[^X] = 2sqrt(p(1-p)/N)

9) Say the actual proportion of Democratic voters is p = 0.45. In this case, the Republican party is winning by a relatively large margin of d = -0.1, or a 10% margin of victory. What is the standard error of the spread 2^X - 1 in this case?

```{r}
# `N` represents the number of people polled
N <- 25

# `p` represents the proportion of Democratic voters
p <- 0.45

# Calculate the standard error of the spread. Print this value to the console.
#SE[^X - (1 - ^X)] = SE[2^X -1] = 2SE[^X] = 2sqrt(p(1-p)/N)

2*sqrt(p*(1-p)/N)
```

10) So far we have said that the difference between the proportion of Democratic voters and Republican voters is about 10% and that the standard error of this spread is about 0.2 when N=25. Select the statement that explains why this sample size is sufficient or not. This sample size is too small because the standard error is larger than the spread.

# The Central Limit Theorem in Practice

CTL tells us that the distribution function for a sum of draws is approximately normal, so the distribution of ^X is also normal. Suppose we want to know the probability that we are within 1% from p:

Pr(^X - p) <= 0.01

Pr(^X <= p + 0.01) - Pr(^X <= p - 0.01)

Subtract the expected value and divide by the standard error to get a standard normal random variable, call it Z, on the left.

Pr(Z <= (0.01/SE[^X])) - Pr(Z <= (-0.01/SE[^X]))

One problem we have is that since we don’t know p, we don’t know SE(^X). But it turns out that the CLT still works if we estimate the standard error by using ^X in place of p. We say that we plug-in the estimate. Our estimate of the standard error is therefore:

SE_hat[^X] = sqrt(^X\*(1-^X)/N)

```{r}
x_hat <- 0.48
se <- sqrt(x_hat*(1-x_hat)/25)
se
```

And now we can answer the question of the probability of being close to p. The answer is:

```{r}
pnorm(0.01/se) - pnorm(-0.01/se)
```

Therefore, there is a small chance that we will be close. A poll of only N=25 people is not really very useful, at least not for a close election.

Earlier we mentioned the margin of error. Now we can define it because it is simply two times the standard error, which we can now estimate. In our case it is:

```{r}
1.96*se
```

Why do we multiply by 1.96? Because if you ask what is the probability that we are within 1.96 standard errors from p, we get:

Pr(Z <= 1.96) - Pr(Z <= -1.96)

which is the 95%

```{r}
pnorm(1.96) - pnorm(-1.96)
```

## Monte Carlo Simulation

Suppose we want to use a Monte Carlo simulation to corroborate the tools we have built using probability theory. To create the simulation, we would write code like this:

```{r}
B <- 10000
N <- 1000
x_hat <- replicate(B, {
  x <- sample(c(0,1), size = N, replace = TRUE, prob = c(1-p, p))
  mean(x)
})
```

The problem is, of course, we don’t know p. One thing we therefore do to corroborate theoretical results is to pick one or several values of p and run the simulations. Let’s set p=0.45. We can then simulate a poll

```{r}
p <- 0.45
N <- 1000

x <- sample(c(0,1), size = N, replace = TRUE, prob = c(1-p, p))
x_hat <- mean(x)

```

In this particular sample, our estimate is x_hat. We can use that code to do a Monte Carlo simulation:

```{r}
B <- 10000
x_hat <- replicate(B, {
  x <- sample(c(0,1), size = N, replace = TRUE, prob = c(1-p, p))
  mean(x)
})

mean(x_hat)
sd(x_hat)
```

Of course, in real life we would never be able to run such an experiment because we don’t know p. But we could run it for various values of p and N and see that the theory does indeed work well for most values. You can easily do this by re-running the code above after changing p and N


## Spread

The competition is to predict the spread, not the proportion p. However, because we are assuming there are only two parties, we know that the spread is p−(1−p)=2p−1. As a result, everything we have done can easily be adapted to an estimate of 2p−1. Once we have our estimate ^X and ^SE(¯X), we estimate the spread with 2^X−1 and, since we are multiplying by 2, the standard error is 2^SE(¯X). Note that subtracting 1 does not add any variability so it does not affect the standard error.

# Exercises

1) Write an urn model function that takes the proportion of Democrats p and the sample size N as arguments and returns the sample average if Democrats are 1s and Republicans are 0s. Call the function take_sample

```{r}
# Write a function called `take_sample` that takes `p` and `N` as arguements and returns the average value of a randomly sampled population.
take_sample <- function(p, N){
  draws <- sample(c(1,0), size = N, replace = T, prob = c(p,1-p))
  mean(draws)
}


# Use the `set.seed` function to make sure your answer matches the expected result after random sampling
set.seed(1)

# Define `p` as the proportion of Democrats in the population being polled
p <- 0.45

# Define `N` as the number of people polled
N <- 100

# Call the `take_sample` function to determine the sample average of `N` randomly selected people from a population containing a proportion of Democrats equal to `p`. Print this value to the console.
take_sample(p,N)
```

2) Now assume p <- 0.45 and that your sample size is N=100. Take a sample 10,000 times and save the vector of mean(X) - p into an object called errors. Hint: use the function you wrote for exercise 1 to write this in one line of code.

```{r}
# Define `p` as the proportion of Democrats in the population being polled
p <- 0.45

# Define `N` as the number of people polled
N <- 100

# The variable `B` specifies the number of times we want the sample to be replicated
B <- 10000

# Use the `set.seed` function to make sure your answer matches the expected result after random sampling
set.seed(1)

# Create an objected called `errors` that replicates subtracting the result of the `take_sample` function from `p` for `B` replications
errors <- replicate(B, p - take_sample(p, N))

# Calculate the mean of the errors. Print this value to the console.
mean(errors)
```

3) The vector errors contains, for each simulated sample, the difference between the actual p and our estimate ¯X. We refer to this difference as the error. Compute the average and make a histogram of the errors generated in the Monte Carlo simulation and select which of the following best describes their distributions:

```{r}
mean(errors)
hist(errors)
```

The errors are symmetrically distributed around 0.

4) The error ¯X−p is a random variable. In practice, the error is not observed because we do not know p. Here we observe it because we constructed the simulation. What is the average size of the error if we define the size by taking the absolute value ∣¯X−p∣?

```{r}
# Define `p` as the proportion of Democrats in the population being polled
p <- 0.45

# Define `N` as the number of people polled
N <- 100

# The variable `B` specifies the number of times we want the sample to be replicated
B <- 10000

# Use the `set.seed` function to make sure your answer matches the expected result after random sampling
set.seed(1)

# We generated `errors` by subtracting the estimate from the actual proportion of Democratic voters
errors <- replicate(B, p - take_sample(p, N))

# Calculate the mean of the absolute value of each simulated error. Print this value to the console.
mean(abs(errors))
```

5) The standard error is related to the typical size of the error we make when predicting. We say size because we just saw that the errors are centered around 0, so thus the average error value is 0. For mathematical reasons related to the Central Limit Theorem, we actually use the standard deviation of errors rather than the average of the absolute values to quantify the typical size. What is this standard deviation of the errors?

```{r}
# Define `p` as the proportion of Democrats in the population being polled
p <- 0.45

# Define `N` as the number of people polled
N <- 100

# The variable `B` specifies the number of times we want the sample to be replicated
B <- 10000

# Use the `set.seed` function to make sure your answer matches the expected result after random sampling
set.seed(1)

# We generated `errors` by subtracting the estimate from the actual proportion of Democratic voters
errors <- replicate(B, p - take_sample(p, N))

# Calculate the standard deviation of `errors`
sqrt(mean(errors^2))
```

6) The theory we just learned tells us what this standard deviation is going to be because it is the standard error of ¯X. What does theory tell us is the standard error of ¯X for a sample size of 100?

```{r}
# Define `p` as the expected value equal to 0.45
p <- 0.45

# Define `N` as the sample size
N <- 100

# Calculate the standard error
se <- sqrt(p*(1-p)/N)
se
```

7) In practice, we don't know p, so we construct an estimate of the theoretical prediction based by plugging in ^X
for p. Calculate the standard error of the estimate: SE_avg[^X]

```{r}
# Define `p` as a proportion of Democratic voters to simulate
p <- 0.45

# Define `N` as the sample size
N <- 100

# Use the `set.seed` function to make sure your answer matches the expected result after random sampling
set.seed(1)

# Define `X` as a random sample of `N` voters with a probability of picking a Democrat ('1') equal to `p`
X <- sample(c(1,0), replace = T, size = N, prob = c(p,1-p))

# Define `X_bar` as the average sampled proportion
X_bar <- mean(X)

# Calculate the standard error of the estimate. Print the result to the console.
se <- sqrt(X_bar*(1-X_bar)/N)
se
```

8) The standard error estimates obtained from the Monte Carlo simulation, the theoretical prediction, and the estimate of the theoretical prediction are all very close, which tells us that the theory is working. This gives us a practical approach to knowing the typical error we will make if we predict p with ^X. The theoretical result gives us an idea of how large a sample size is required to obtain the precision we need. Earlier we learned that the largest standard errors occur for p = 0.5. Create a plot of the largest standard error for
ranging from 100 to 5,000. Based on this plot, how large does the sample size have to be to have a standard error of about 1%?

```{r}
N <- seq(100, 5000, len = 100)
p <- 0.5
se <- sqrt(p*(1-p)/N)

ggplot(data.frame(se, N), aes(x = se, y = N))+geom_line()
```

9) For N=100, the central limit theorem tells us that the distribution of ^X is... Approximately normal with expected value p and standard error sqrt((p\*(1-p))/N).

10) We calculated a vector errors that contained, for each simulated sample, the difference between the actual value p and our estimate ^X. The errors ^X - p are approximately normal with expected value $0$ and standard error $\sqrt{p(1-p)/N}$.

11) To corroborate your answer to exercise 9, make a qq-plot of the `errors` you generated in exercise 2 to see if they follow a normal distribution.

```{r}
qqnorm(errors)
qqline(errors)
```

12) If $p=0.45$ and $N=100$ as in exercise 2, use the CLT to estimate the probability that $\bar{X}>0.5$. You can assume you know $p=0.45$ for this calculation.

```{r}
p <- 0.45
N <- 100
1 - pnorm(0.5, p, sqrt(p*(1-p)/N))
```

13) Assume you are in a practical situation and you don't know $p$. Take a sample of size $N=100$ and obtain a sample average of $\bar{X} = 0.51$. What is the CLT approximation for the probability that your error is equal or larger than 0.01?

```{r}
N <-100
X_hat <- 0.51
se_hat <- sqrt(X_hat*(1-X_hat)/N)
1 - pnorm(.01, 0, se_hat) + pnorm(-0.01, 0, se_hat)
```

# Confidence Intervals

Confidence intervals are a very useful concept widely employed by data analysts. A version of these that are commonly seen come from the ggplot geometry geom_smooth.

In our earlier competition, you were asked to give an interval. If the interval you submitted includes the p, you get half the money you spent on your “poll” back and pass to the next stage of the competition. One way to pass to the second round is to report a very large interval. For example, the interval [0,1] is guaranteed to include p. However, with an interval this big, we have no chance of winning the competition. Similarly, if you are an election forecaster and predict the spread will be between -100% and 100%, you will be ridiculed for stating the obvious. Even a smaller interval, such as saying the spread will be between -10 and 10%, will not be considered serious.

On the other hand, the smaller the interval we report, the smaller our chances are of winning the prize. Likewise, a bold pollster that reports very small intervals and misses the mark most of the time will not be considered a good pollster. We want to be somewhere in between.

We can use the statistical theory we have learned to compute the probability of any given interval including p. If we are asked to create an interval with, say, a 95% chance of including p, we can do that as well. These are called 95% confidence intervals.

We want to know the probability that the interval [¯X−2^SE(¯X),¯X+2^SE(¯X)] contains the true proportion p. First, consider that the start and end of these intervals are random variables: every time we take a sample, they change.

```{r}
p <- 0.45
N <- 1000

set.seed(123)
x <- sample(c(0, 1), size = N, replace = TRUE, prob = c(1-p, p))
x_hat <- mean(x)
se_hat <- sqrt(x_hat * (1 - x_hat) / N)
c(x_hat - 1.96 * se_hat, x_hat + 1.96 * se_hat)

set.seed(189)
x <- sample(c(0, 1), size = N, replace = TRUE, prob = c(1-p, p))
x_hat <- mean(x)
se_hat <- sqrt(x_hat * (1 - x_hat) / N)
c(x_hat - 1.96 * se_hat, x_hat + 1.96 * se_hat)
```

To determine the probability that the interval includes p, we need to compute this:

Pr(^X - 1.96^SE(^X) <= p <= ^X + 1.96^SE(^X))
Pr(-1.96 <= Z <= 1.96)

```{r}
pnorm(1.96) - pnorm(-1.96)
```

If we want a larger probability, we need to multiply by whatever Z satisfies the following:

Pr(-z <= Z <= z) = 0.99

```{r}
p <- 0.995
z <- qnorm(p)
pnorm(z) - pnorm(-z)
```

We can use this approach for any probability, not just 0.95 and 0.99. In statistics textbooks, these are usually written for any probability as 1−α. We can then obtain the z for the equation above noting using 
z = qnorm(1 - alpha / 2) because 1−α/2−α/2=1−α.

So, for example, for α=0.05, 1−α/2=0.975 and we get the 1.96 we have been using:

```{r}
qnorm(0.975)


# expected p

p <- c(0.9, 0.95, 0.99)
a <- 1 - p
z <- qnorm(1-a/2)
pnorm(z) - pnorm(-z)
```

## Monte Carlo Simulation

We can run a Monte Carlo simulation to confirm that, in fact, a 95% confidence interval includes p 95% of the time

```{r}
library(dplyr)
p <- 0.45
N <- 1000
B <- 10000
inside <- replicate(B, {
  x <- sample(c(0,1), size = N, replace = TRUE, prob = c(1-p, p))
  x_hat <- mean(x)
  se_hat <- sqrt(x_hat * (1 - x_hat) / N)
  between(p, x_hat - 1.96 * se_hat, x_hat + 1.96 * se_hat)
})
mean(inside)
```


# Exercises

For these exercises, we will use actual polls from the 2016 election. You can load the data from the dslabs package.

Specifically, we will use all the national polls that ended within one week before the election.

1) Assume there are only two candidates and construct a 95% confidence interval for the election night proportion.

```{r}
library(tidyverse)
library(dslabs)
data(polls_us_election_2016)

# Generate an object `polls` that contains data filtered for polls that ended on or after October 31, 2016 in the United States
polls <- polls_us_election_2016 |> 
  filter(enddate >= "2016-10-31" & state == "U.S.")


# How many rows does `polls` contain? Print this value to the console.
nrow(polls)

# Assign the sample size of the first poll in `polls` to a variable called `N`. Print this value to the console.
N <- head(polls$samplesize,1)
N


# For the first poll in `polls`, assign the estimated percentage of Clinton voters to a variable called `X_hat`. Print this value to the console.
X_hat <- head(polls$rawpoll_clinton,1)/100
X_hat

# Calculate the standard error of `X_hat` and save it to a variable called `se_hat`. Print this value to the console.
se_hat <- sqrt(X_hat * (1 - X_hat) / N)
se_hat

# Use `qnorm` to calculate the 95% confidence interval for the proportion of Clinton voters. Save the lower and then the upper confidence interval to a variable called `ci`.
a <- 0.05
z <- qnorm(1-a/2)
ci <- c(X_hat - z * se_hat, X_hat + z * se_hat)
ci
```

2) Now use dplyr to add a confidence interval as two columns, call them lower and upper, to the object poll. Then use select to show the pollster, enddate, x_hat,lower, upper variables. Hint: define temporary columns x_hat and se_hat.

```{r}
# Create a new object called `pollster_results` that contains columns for pollster name, end date, X_hat, se_hat, lower confidence interval, and upper confidence interval for each poll.
polls <- mutate(polls, X_hat = polls$rawpoll_clinton/100, se_hat = sqrt(X_hat*(1-X_hat)/polls$samplesize), lower = X_hat - qnorm(0.975)*se_hat, upper = X_hat + qnorm(0.975)*se_hat)
pollster_results <- select(polls, pollster, enddate, X_hat, se_hat, lower, upper)
pollster_results
```

3) The final tally for the popular vote was Clinton 48.2% and Trump 46.1%. Add a column, call it hit, to the previous table stating if the confidence interval included the true proportion p=0.482 or not.

```{r}
# Add a logical variable called `hit` that indicates whether the actual value exists within the confidence interval of each poll. Summarize the average `hit` result to determine the proportion of polls with confidence intervals include the actual value. Save the result as an object called `avg_hit`.
avg_hit <- pollster_results %>% mutate(hit=(lower<0.482 & upper>0.482))
avg_hit
```

4) For the table you just created, what proportion of confidence intervals included p?

```{r}
avg_hit %>% summarise(mean(hit))
```


5) If these confidence intervals are constructed correctly, and the theory holds up, what proportion of confidence intervals should include p? - 0.95

6) A much smaller proportion of the polls than expected produce confidence intervals containing p. If you look closely at the table, you will see that most polls that fail to include p are underestimating. The reason for this is undecided voters, individuals polled that do not yet know who they will vote for or do not want to say. Because, historically, undecideds divide evenly between the two main candidates on election day, it is more informative to estimate the spread or the difference between the proportion of two candidates d, which in this election was 0.482−0.461=0.021.

```{r}
# contrast that p is understimate

ggplot(avg_hit)+
  geom_point(aes(y = pollster, x = X_hat, color = hit))+
  geom_vline(xintercept = 0.482)
```

```{r}
# Add a statement to this line of code that will add a new column named `d_hat` to `polls`. The new column should contain the difference in the proportion of voters.
polls <- polls_us_election_2016 %>% filter(enddate >= "2016-10-31" & state == "U.S.") %>% 
  mutate(d_hat = rawpoll_clinton/100 - rawpoll_trump/100)

```

Assume that there are only two parties and that d=2p−1, redefine polls as below and re-do exercise 1, but for the difference.

```{r}
N <- polls$samplesize[1]
d_hat <- polls$d_hat[1]
X_hat <- (d_hat+1)/2
se_hat <- 2*sqrt(X_hat*(1-X_hat)/N)
d_hat + c(-1,1)*pnorm(0.975)*se_hat
```

7) Now repeat exercise 3, but for the difference.
```{r}
polls %>% mutate(X_hat = (d_hat+1)/2, se_hat = 2*sqrt(X_hat*(1-X_hat)/samplesize),
                 lower = d_hat - pnorm(0.975)*se_hat, upper = d_hat + pnorm(0.975)*se_hat, 
                 hit = lower<=0.021 & upper>=0.021) %>%
  select(pollster, enddate, d_hat, lower, upper, hit) 
```

8) Now repeat exercise 4

```{r}
polls %>% mutate(X_hat = (d_hat+1)/2, se_hat = 2*sqrt(X_hat*(1-X_hat)/samplesize),
                 lower = d_hat - pnorm(0.975)*se_hat, upper = d_hat + pnorm(0.975)*se_hat, 
                 hit = lower<=0.021 & upper>=0.021) %>%
  select(pollster, enddate, d_hat, lower, upper, hit) %>% 
  summarize(mean(hit))
```

9) Although the proportion of confidence intervals goes up substantially, it is still lower than 0.95. In the next chapter, we learn the reason for this. To motivate this, make a plot of the error, the difference between each poll’s estimate and the actual d=0.021. Stratify by pollster.

```{r}
polls %>% mutate(error = d_hat - 0.021) %>%
  ggplot(aes(pollster, error)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

10) Re-do the plot but for pollsters that took more than 5 polls

```{r}
polls %>% mutate(error = d_hat - 0.021) %>%
  group_by(pollster) %>%
  filter(n() >= 5) %>%
  ggplot(aes(pollster, error)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```


# Power

Pollsters are not successful at providing correct confidence intervals, but rather at predicting who will win. When we took a 25 bead sample size, the confidence interval for the spread:

```{r}
N <- 25
x_hat <- 0.48
(2 * x_hat - 1) + c(-1.96, 1.96) * 2 * sqrt(x_hat * (1 - x_hat) / N)
```

includes 0. If this were a poll and we were forced to make a declaration, we would have to say it was a “toss-up”.

A problem with our poll results is that given the sample size and the value of p, we would have to sacrifice on the probability of an incorrect call to create an interval that does not include 0. This does not mean that the election is close. It only means that we have a small sample size. In statistical textbooks this is called lack of power. In the context of polls, power is the probability of detecting spreads different from 0.

By increasing our sample size, we lower our standard error and therefore have a much better chance of detecting the direction of the spread.

# p-values

p-values are ubiquitous in the scientific literature. They are related to confidence intervals so we introduce the concept here. Let’s consider the blue and red beads. Suppose that rather than wanting an estimate of the spread or the proportion of blue, I am interested only in the question: are there more blue beads or red beads? I want to know if the spread or, equivalently, if p>0.5.

Say we take a random sample of N=100 and we observe 52 blue beads, which gives us ¯X=0.52. This seems to be pointing to the existence of more blue than red beads since 0.52 is larger than 0.5. However, as data scientists we need to be skeptical. We know there is chance involved in this process and we could get a 52 even when the actual spread is 0. We call the assumption that the spread is p=0.5 a null hypothesis. The null hypothesis is the skeptic’s hypothesis. We have observed a random variable ¯X=0.52 and the p-value is the answer to the question: how likely is it to see a value this large, when the null hypothesis is true? So we write:

Pr(|^X - 0.5| > 0.02)

Assuming the p = 0.5. Under the null hypothesis we know that:

sqr(N) \* (^x - 0.5)/sqrt(0.5*(1-0.5))

```{r}
N <- 100
z <- sqrt(N)*0.02/0.5
1 - (pnorm(z) - pnorm(-z))
```

In this case, there is actually a large chance of seeing 52 or larger under the null hypothesis. Keep in mind that there is a close connection between p-values and confidence intervals. If a 95% confidence interval of the spread does not include 0, we know that the p-value must be smaller than 0.05.

# Association Tests

The statistical tests we have studied up to now leave out a substantial portion of data types. Specifically, we have not discussed inference for binary, categorical, and ordinal data. To give a very specific example, consider the following case study.

A 2014 PNAS paper analyzed success rates from funding agencies in the Netherlands and concluded that their:

"results reveal gender bias favoring male applicants over female applicants in the prioritization of their “quality of researcher” (but not “quality of proposal”) evaluations and success rates, as well as in the language use in instructional and evaluation materials"

```{r}
library(tidyverse)
library(dslabs)
data("research_funding_rates")
research_funding_rates |> select(discipline, applications_total, 
                                  success_rates_total) |> head()


totals <- research_funding_rates |> 
  select(-discipline) |> 
  summarize_all(sum) |>
  summarize(yes_men = awards_men, 
            no_men = applications_men - awards_men, 
            yes_women = awards_women, 
            no_women = applications_women - awards_women) 

totals |> summarize(percent_men = yes_men/(yes_men+no_men),
                     percent_women = yes_women/(yes_women+no_women))
```

So we see that a larger percent of men than women received awards. But could this be due just to random variability? Here we learn how to perform inference for this type of data.

## Lady Tasting Tea

R.A. Fisher was one of the first to formalize hypothesis testing. The “Lady Tasting Tea” is one of the most famous examples.

The story is as follows: an acquaintance of Fisher’s claimed that she could tell if milk was added before or after tea was poured. Fisher was skeptical. He designed an experiment to test this claim. He gave her four pairs of cups of tea: one with milk poured first, the other after. The order was randomized. The null hypothesis here is that she is guessing. Fisher derived the distribution for the number of correct picks on the assumption that the choices were random and independent.

As an example, suppose she picked 3 out of 4 correctly. Do we believe she has a special ability? The basic question we ask is: if the tester is actually guessing, what are the chances that she gets 3 or more correct? Just as we have done before, we can compute a probability under the null hypothesis that she is guessing 4 of each. Under this null hypothesis, we can think of this particular example as picking 4 balls out of an urn with 4 blue (correct answer) and 4 red (incorrect answer) balls. Remember, she knows that there are four before tea and four after.

Under the null hypothesis that she is simply guessing, each ball has the same chance of being picked. We can then use combinations to figure out each probability. 

The probability of picking 3 is (4/3)(4/1)/(8/4) = 16/70

The probability of picking 4 is (4/4)(4/0)/(8/4) = 1/70

Thus, the chance of observing a 3 or something more extreme, under the null hypothesis, is ≈0.24. This is the p-value. The procedure that produced this p-value is called Fisher’s exact test and it uses the hypergeometric distribution.

## Two-by-Two Tables

The data from the experiment is usually summarized by a table like this:

```{r}
tab <- matrix(c(3,1,1,3),2,2)
rownames(tab)<-c("Poured Before","Poured After")
colnames(tab)<-c("Guessed before","Guessed after")
tab

fisher.test(tab, alternative="greater")$p.value
```

## Chi-Square Test

Notice that, in a way, our funding rates example is similar to the Lady Tasting Tea. However, in the Lady Tasting Tea example, the number of blue and red beads is experimentally fixed and the number of answers given for each category is also fixed. This is because Fisher made sure there were four cups with milk poured before tea and four cups with milk poured after and the lady knew this, so the answers would also have to include four befores and four afters. If this is the case, the sum of the rows and the sum of the columns are fixed. This defines constraints on the possible ways we can fill the two by two table and also permits us to use the hypergeometric distribution. In general, this is not the case. Nonetheless, there is another approach, the Chi-squared test, which is described below.

Imagine we have 290, 1,345, 177, 1,011 applicants, some are men and some are women and some get funded, whereas others don’t. We saw that the success rates for men and woman were:

```{r}
totals |> summarize(percent_men = yes_men/(yes_men+no_men),
                     percent_women = yes_women/(yes_women+no_women))
```

respectively. Would we see this again if we randomly assign funding at the overall rate:

```{r}
rate <- totals |>
  summarize(percent_total = 
              (yes_men + yes_women)/
              (yes_men + no_men +yes_women + no_women)) |>
  pull(percent_total)
rate
```

The Chi-square test answers this question. The first step is to create the two-by-two data table:

```{r}
two_by_two <- data.frame(awarded = c("no", "yes"), 
                     men = c(totals$no_men, totals$yes_men),
                     women = c(totals$no_women, totals$yes_women))
two_by_two
```

The general idea of the Chi-square test is to compare this two-by-two table to what you expect to see

```{r}
data.frame(awarded = c("no", "yes"), 
       men = (totals$no_men + totals$yes_men) * c(1 - rate, rate),
       women = (totals$no_women + totals$yes_women) * c(1 - rate, rate))
```

We can see that more men than expected and fewer women than expected received funding. However, under the null hypothesis these observations are random variables. The Chi-square test tells us how likely it is to see a deviation this large or larger. This test uses an asymptotic result, similar to the CLT, related to the sums of independent binary outcomes. The R function chisq.test takes a two-by-two table and returns the results from the test:

```{r}
chisq_test <- two_by_two |> select(-awarded) |> chisq.test()
chisq_test$p.value
```

## Odds Ratio

An informative summary statistic associated with two-by-two tables is the odds ratio. Define the two variables as X=1 if you are a male and 0 otherwise, and Y=1 if you are funded and 0 otherwise. The odds of getting funded if you are a man is defined:

Pr(Y=1∣X=1)/Pr(Y=0∣X=1)

```{r}
odds_men <- with(two_by_two, (men[2]/sum(men)) / (men[1]/sum(men)))
odds_men
```

And the odds of being funded if you are a woman is:

Pr(Y=1∣X=0)/Pr(Y=0∣X=0)

```{r}
odds_women <- with(two_by_two, (women[2]/sum(women)) / (women[1]/sum(women)))
odds_women
```

The odds ratio is the ratio for these two odds: how many times larger are the odds for men than for women?

```{r}
odds_men / odds_women
```

```{r}
data.frame(awarded = c("yes", "no"), 
       men = c("a","c"),
       women = c("b","d"))
```

odds ratio = (ad)/(bc)


## Confidence intervals for the odds ratio

Computing confidence intervals for the odds ratio is not mathematically straightforward. Unlike other statistics, for which we can derive useful approximations of their distributions, the odds ratio is not only a ratio, but a ratio of ratios. Therefore, there is no simple way of using, for example, the CLT.

However, statistical theory tells us that when all four entries of the two-by-two table are large enough, then the log of the odds ratio is approximately normal with standard error

sqrt(1/a+1/b+1/c+1/d)

This implies that a 95% confidence interval for the log odds ratio can be formed by:

log(ad/bc) +- 1.96*sqrt(1/a+1/b+1/c+1/d)

```{r}
log_or <- log(odds_men / odds_women)
se <- two_by_two |> select(-awarded) |>
  summarize(se = sqrt(sum(1/men) + sum(1/women))) |>
  pull(se)
ci <- log_or + c(-1,1) * qnorm(0.975) * se
odds_ratio <- exp(ci)
odds_ratio
```

Note that 1 is not included in the confidence interval which must mean that the p-value is smaller than 0.05. We can confirm this using:

```{r}
2*(1 - pnorm(log_or, 0, se))
```

This is a slightly different p-value than that with the Chi-square test. This is because we are using a different asymptotic approximation to the null distribution. To learn more about inference and asymptotic theory for odds ratio, consult the Generalized Linear Models book by McCullagh and Nelder.

## Large samples, small p-values

As mentioned earlier, reporting only p-values is not an appropriate way to report the results of data analysis. In scientific journals, for example, some studies seem to overemphasize p-values. Some of these studies have large sample sizes and report impressively small p-values. Yet when one looks closely at the results, we realize odds ratios are quite modest: barely bigger than 1. In this case the difference may not be practically significant or scientifically significant.

Note that the relationship between odds ratio and p-value is not one-to-one. It depends on the sample size. So a very small p-value does not necessarily mean a very large odds ratio. Notice what happens to the p-value if we multiply our two-by-two table by 10, which does not change the odds ratio:

```{r}
two_by_two_x_10 <- two_by_two |> 
  select(-awarded) |>
  mutate(men = men*10, women = women*10) 
chisq.test(two_by_two_x_10)$p.value
```


# Exercises

1) A famous athlete has an impressive career, winning 70% of her 500 career matches. However, this athlete gets criticized because in important events, such as the Olympics, she has a losing record of 8 wins and 9 losses. Perform a Chi-square test to determine if this losing record can be simply due to chance as opposed to not performing well under pressure.

```{r}
N <- 500
win_rate <- 0.7
wins <- N * win_rate
losses <- 500 - wins

athlete_performance <- matrix(c(wins, losses, 8, 9),2,2)
rownames(athlete_performance) <- c("wins", "losses")
colnames(athlete_performance) <- c("career","olympics")
athlete_performance

chisq_test <- athlete_performance |> chisq.test()
chisq_test$p.value

# As p > 0.05 we do not reject H0 =>  a p-value of 0.08 suggests that there may not be strong evidence to conclude that the athlete's performance in career matches and in the Olympics are significantly related. we cannot confirm that the losing record in important events is simply due to chance.
```

2) Why did we use the Chi-square test instead of Fisher’s exact test in the previous exercise? - 


```{r}
fisher_test <- athlete_performance |> fisher.test()
fisher_test$p.value
```

3) Compute odds ratio of "losing under pressure" along with a confidence interval

```{r}
athlete_performance <- as.data.frame(athlete_performance)
odds_career <- with(athlete_performance, (career[2]/sum(career)) / (career[1]/sum(career)))
odds_olympics <- with(athlete_performance, (olympics[2]/sum(olympics)) / (olympics[1]/sum(olympics)))
odds_ratio <- odds_career / odds_olympics

log_or <- log(odds_career / odds_olympics)
se <- athlete_performance |>
  summarize(se = sqrt(sum(1/career) + sum(1/olympics))) |>
  pull(se)
ci <- log_or + c(-1,1) * qnorm(0.975) * se
odds_ratio <- exp(ci)
odds_ratio
```

